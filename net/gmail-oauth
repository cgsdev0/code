#!/usr/bin/python3
# gmail-oauth -- Mutt helper for Gmail's OAUTHBEARER and XOAUTH2 mechanisms
#
# Original version from: <https://github.com/google/gmail-oauth2-tools>
# (c) 2012 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Performs client tasks for testing IMAP OAuth2 authentication.

To use this script, you'll need to have registered with Google as an OAuth
application and obtained an OAuth client ID and client secret.
See https://developers.google.com/identity/protocols/OAuth2 for instructions on
registering and for documentation of the APIs invoked by this code.

This script has 3 modes of operation.

1. The first mode is used to generate and authorize an OAuth2 token, the
first step in logging in via OAuth2.

    oauth2 --user=xxx@gmail.com \
        --client_id=1038[...].apps.googleusercontent.com \
        --client_secret=VWFn8LIKAMC-MsjBMhJeOplZ \
        --generate_oauth2_token

The script will converse with Google and generate an oauth request
token, then present you with a URL you should visit in your browser to
authorize the token. Once you get the verification code from the Google
website, enter it into the script to get your OAuth access token. The output
from this command will contain the access token, a refresh token, and some
metadata about the tokens. The access token can be used until it expires, and
the refresh token lasts indefinitely, so you should record these values for
reuse.

2. The script will generate new access tokens using a refresh token.

    oauth2 --user=xxx@gmail.com \
        --client_id=1038[...].apps.googleusercontent.com \
        --client_secret=VWFn8LIKAMC-MsjBMhJeOplZ \
        --refresh_token=1/Yzm6MRy4q1xi7Dx2DuWXNgT6s37OrP_DW_IoyTum4YA

3. The script will generate an OAuth2 string that can be fed
directly to IMAP or SMTP. This is triggered with the --generate_oauth2_string
option.

    oauth2 --generate_oauth2_string --user=xxx@gmail.com \
        --access_token=ya29.AGy[...]ezLg

The output of this mode will be a base64-encoded string. To use it, connect to a
IMAPFE and pass it as the second argument to the AUTHENTICATE command.

    a AUTHENTICATE XOAUTH2 a9sha9sfs[...]9dfja929dk==
"""

import argparse
import base64
import imaplib
import json
from nullroute.core import Core
import smtplib
import sys
import urllib.request, urllib.parse, urllib.error

# The URL root for accessing Google Accounts
GOOGLE_ACCOUNTS_BASE_URL = "https://accounts.google.com"

# Hardcoded dummy redirect URI for non-web apps
REDIRECT_URI = "urn:ietf:wg:oauth:2.0:oob"

def UrlEscape(text):
    # See OAUTH 5.1 for a definition of which characters need to be escaped.
    return urllib.parse.quote(text, safe='~-._')

def UrlUnescape(text):
    # See OAUTH 5.1 for a definition of which characters need to be escaped.
    return urllib.parse.unquote(text)

def fmt_url_query_string(params):
    """Formats parameters into a URL query string.

    Args:
        params: A key-value map.

    Returns:
        A URL query string version of the given parameters.
    """
    param_fragments = []
    for param in sorted(params.items(), key=lambda x: x[0]):
        param_fragments.append("%s=%s" % (param[0], UrlEscape(param[1])))
    return "&".join(param_fragments)

def make_oauth2_permission_url(client_id, scope='https://mail.google.com/'):
    """Generates the URL for authorizing access.

    This uses the "OAuth2 for Installed Applications" flow described at
    https://developers.google.com/identity/protocols/OAuth2InstalledApp

    Args:
        client_id: Client ID obtained by registering your app.
        scope: scope for access token, e.g. 'https://mail.google.com'
    Returns:
        A URL that the user should visit in their browser.
    """
    request_url = GOOGLE_ACCOUNTS_BASE_URL + "/o/oauth2/auth"
    params = {
        "client_id": client_id,
        "redirect_uri": REDIRECT_URI,
        "response_type": "code",
        "scope": scope,
    }
    return "%s?%s" % (request_url, fmt_url_query_string(params))

def get_access_token(client_id, client_secret, authorization_code):
    """Obtains OAuth access token and refresh token.

    This uses the application portion of the "OAuth2 for Installed Applications"
    flow at https://developers.google.com/accounts/docs/OAuth2InstalledApp#handlingtheresponse

    Args:
        client_id: Client ID obtained by registering your app.
        client_secret: Client secret obtained by registering your app.
        authorization_code: code generated by Google Accounts after user grants
                permission.
    Returns:
        The decoded response from the Google Accounts server, as a dict. Expected
        fields include 'access_token', 'expires_in', and 'refresh_token'.
    """
    request_url = GOOGLE_ACCOUNTS_BASE_URL + "/o/oauth2/token"
    params = {
        "client_id": client_id,
        "client_secret": client_secret,
        "code": authorization_code,
        "grant_type": "authorization_code",
        "redirect_uri": REDIRECT_URI,
    }
    post_data = urllib.parse.urlencode(params).encode()
    response = urllib.request.urlopen(request_url, post_data).read()
    return json.loads(response)

def refresh_access_token(client_id, client_secret, refresh_token):
    """Obtains a new token given a refresh token.

    See https://developers.google.com/accounts/docs/OAuth2InstalledApp#refresh

    Args:
        client_id: Client ID obtained by registering your app.
        client_secret: Client secret obtained by registering your app.
        refresh_token: A previously-obtained refresh token.
    Returns:
        The decoded response from the Google Accounts server, as a dict. Expected
        fields include 'access_token', 'expires_in', and 'refresh_token'.
    """
    request_url = GOOGLE_ACCOUNTS_BASE_URL + "/o/oauth2/token"
    params = {
        "client_id": client_id,
        "client_secret": client_secret,
        "grant_type": "refresh_token",
        "refresh_token": refresh_token,
    }
    post_data = urllib.parse.urlencode(params).encode()
    response = urllib.request.urlopen(request_url, post_data).read()
    return json.loads(response)

def sasl_xoauth2_response(username, access_token):
    # https://developers.google.com/gmail/imap/xoauth2-protocol
    buf = "user=%s\1auth=Bearer %s\1\1" % (username, access_token)
    return buf.encode()

def test_imap_auth(user, auth_string):
    imap_conn = imaplib.IMAP4_SSL("imap.gmail.com")
    imap_conn.debug = 4
    imap_conn.authenticate("XOAUTH2", lambda x: auth_string)
    imap_conn.select("INBOX")

def test_smtp_auth(user, auth_string):
    smtp_conn = smtplib.SMTP("smtp.gmail.com", 587)
    smtp_conn.set_debuglevel(True)
    smtp_conn.ehlo("test")
    smtp_conn.starttls()
    smtp_conn.docmd("AUTH", "XOAUTH2 " + base64.b64encode(auth_string).decode())

def require_args(options, *args):
    missing = ["--%s" % arg for arg in args if getattr(options, arg.replace("-", "_")) is None]
    if missing:
        Core.die("missing options: %s" % ", ".join(missing))

def decline_args(options, *args):
    useless = ["--%s" % arg for arg in args if getattr(options, arg.replace("-", "_")) is not None]
    if useless:
        Core.warn("option %s useless in this mode" % ", ".join(useless))

def main(argv):
    parser = argparse.ArgumentParser()
    # modes
    parser.add_argument("--authorize-app", action="store_true", help="interactively obtain the initial OAuth2 token")
    parser.add_argument("--generate-oauth2-string", action="store_true", help="generate an initial client response string for OAuth2")
    parser.add_argument("--test-imap", action="store_true", help="attempts to authenticate to IMAP")
    parser.add_argument("--test-smtp", action="store_true", help="attempts to authenticate to SMTP")
    # options
    parser.add_argument("--client-id", help="OAuth2 Client ID of the application that is authenticating")
    parser.add_argument("--client-secret", help="OAuth2 Client secret of the application")
    parser.add_argument("--access-token", help="OAuth2 access token")
    parser.add_argument("--refresh-token", help="OAuth2 refresh token")
    parser.add_argument("--authorization-code", help="OAuth2 authorization code")
    parser.add_argument("--scope", default="https://mail.google.com/", help="scopes for the access token, space-separated")
    parser.add_argument("--user", help="email address of user whose account is being accessed")
    parser.add_argument("--quiet", action="store_true", help="Omit verbose descriptions and only print machine-readable outputs.")
    parser.add_argument("--json", action="store_true", help="Show JSON-formatted output description")
    args = parser.parse_args()

    if args.authorize_app or args.authorization_code:
        require_args(args, "client-id", "client-secret")
        decline_args(args, "access-token", "refresh-token")

        if args.authorization_code:
            authorization_code = args.authorization_code
        else:
            url = make_oauth2_permission_url(args.client_id, args.scope)
            if args.quiet:
                print(url)
                authorization_code = input()
            else:
                print("Visit this URL: %s", url)
                authorization_code = input("Enter verification code: ")

        response = get_access_token(args.client_id, args.client_secret, authorization_code)
        if args.quiet:
            print(response["access_token"])
            print(response["refresh_token"])
        else:
            print(json.dumps(response))

    elif args.refresh_token:
        require_args(args, "client-id", "client-secret", "refresh-token")
        decline_args(args, "access-token", "authorization-code")

        response = refresh_access_token(args.client_id, args.client_secret, args.refresh_token)
        if args.quiet:
            print(response["access_token"])
        else:
            print(json.dumps(response))

    elif args.generate_oauth2_string:
        require_args(args, "user", "access-token")
        decline_args(args, "client-id", "client-secret", "refresh-token", "authorization-code")
        oauth2_string = sasl_xoauth2_response(args.user, args.access_token)
        print(base64.b64encode(oauth2_string).decode())

    elif args.test_imap:
        require_args(args, "user", "access-token")
        decline_args(args, "client-id", "client-secret", "refresh-token", "authorization-code")
        test_imap_auth(args.user, sasl_xoauth2_response(args.user, args.access_token))

    elif args.test_smtp:
        require_args(args, "user", "access-token")
        decline_args(args, "client-id", "client-secret", "refresh-token", "authorization-code")
        test_smtp_auth(args.user, sasl_xoauth2_response(args.user, args.access_token))

    else:
        Core.die("no mode specified")

if __name__ == "__main__":
    main(sys.argv)
