#!/usr/bin/python3
# gmail-oauth -- Mutt helper for Gmail's OAUTHBEARER and XOAUTH2 mechanisms
#
# Original version from: <https://github.com/google/gmail-oauth2-tools>
# (c) 2012 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#            http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import base64
import imaplib
import json
from nullroute.core import Core
import smtplib
import sys
import urllib.request, urllib.parse, urllib.error

# The URL root for accessing Google Accounts
GOOGLE_ACCOUNTS_BASE_URL = "https://accounts.google.com"

# Hardcoded dummy redirect URI for non-web apps
REDIRECT_URI = "urn:ietf:wg:oauth:2.0:oob"

def UrlEscape(text):
    # See OAUTH 5.1 for a definition of which characters need to be escaped.
    return urllib.parse.quote(text, safe='~-._')

def UrlUnescape(text):
    # See OAUTH 5.1 for a definition of which characters need to be escaped.
    return urllib.parse.unquote(text)

def sasl_gs2_escape(text):
    return text.replace("=", "=3D").replace(",", "=2C")

def fmt_url_query_string(params):
    """Formats parameters into a URL query string.

    Args:
        params: A key-value map.

    Returns:
        A URL query string version of the given parameters.
    """
    param_fragments = []
    for param in sorted(params.items(), key=lambda x: x[0]):
        param_fragments.append("%s=%s" % (param[0], UrlEscape(param[1])))
    return "&".join(param_fragments)

def make_oauth2_permission_url(client_id, scope='https://mail.google.com/'):
    """Generates the URL for authorizing access.

    This uses the "OAuth2 for Installed Applications" flow described at
    https://developers.google.com/identity/protocols/OAuth2InstalledApp

    Args:
        client_id: Client ID obtained by registering your app.
        scope: scope for access token, e.g. 'https://mail.google.com'
    Returns:
        A URL that the user should visit in their browser.
    """
    request_url = GOOGLE_ACCOUNTS_BASE_URL + "/o/oauth2/auth"
    params = {
        "client_id": client_id,
        "redirect_uri": REDIRECT_URI,
        "response_type": "code",
        "scope": scope,
    }
    return "%s?%s" % (request_url, fmt_url_query_string(params))

def get_access_token(client_id, client_secret, authorization_code):
    """Obtains OAuth access token and refresh token.

    This uses the application portion of the "OAuth2 for Installed Applications"
    flow at https://developers.google.com/accounts/docs/OAuth2InstalledApp#handlingtheresponse

    Args:
        client_id: Client ID obtained by registering your app.
        client_secret: Client secret obtained by registering your app.
        authorization_code: code generated by Google Accounts after user grants
                permission.
    Returns:
        The decoded response from the Google Accounts server, as a dict. Expected
        fields include 'access_token', 'expires_in', and 'refresh_token'.
    """
    request_url = GOOGLE_ACCOUNTS_BASE_URL + "/o/oauth2/token"
    params = {
        "client_id": client_id,
        "client_secret": client_secret,
        "code": authorization_code,
        "grant_type": "authorization_code",
        "redirect_uri": REDIRECT_URI,
    }
    post_data = urllib.parse.urlencode(params).encode()
    response = urllib.request.urlopen(request_url, post_data).read()
    return json.loads(response)

def refresh_access_token(client_id, client_secret, refresh_token):
    """Obtains a new token given a refresh token.

    See https://developers.google.com/accounts/docs/OAuth2InstalledApp#refresh

    Args:
        client_id: Client ID obtained by registering your app.
        client_secret: Client secret obtained by registering your app.
        refresh_token: A previously-obtained refresh token.
    Returns:
        The decoded response from the Google Accounts server, as a dict. Expected
        fields include 'access_token', 'expires_in', and 'refresh_token'.
    """
    request_url = GOOGLE_ACCOUNTS_BASE_URL + "/o/oauth2/token"
    params = {
        "client_id": client_id,
        "client_secret": client_secret,
        "grant_type": "refresh_token",
        "refresh_token": refresh_token,
    }
    post_data = urllib.parse.urlencode(params).encode()
    response = urllib.request.urlopen(request_url, post_data).read()
    return json.loads(response)

def sasl_xoauth2_response(username, access_token):
    # https://developers.google.com/gmail/imap/xoauth2-protocol
    http_authz = "Bearer %s" % access_token
    buf = "user=%s\1auth=%s\1\1" % (username, http_authz)
    return buf.encode()

def sasl_oauthbearer_response(username, access_token):
    # https://tools.ietf.org/html/rfc5801#section-4
    gs2_header = "n,a=%s," % sasl_gs2_escape(username)
    # https://tools.ietf.org/html/rfc6750#section-2.1
    http_authz = "Bearer %s" % access_token
    # https://tools.ietf.org/html/rfc7628#section-3.1
    buf = "%s\1auth=%s\1\1" % (gs2_header, http_authz)
    return buf.encode()

def test_imap_auth(user, mech, auth_string):
    print("testing mechanism %s with auth_string %r" % (mech, auth_string))
    imap_conn = imaplib.IMAP4_SSL("imap.gmail.com")
    imap_conn.debug = 4
    imap_conn.authenticate(mech, lambda x: auth_string)
    imap_conn.select("INBOX")

def test_smtp_auth(user, mech, auth_string):
    print("testing mechanism %s with auth_string %r" % (mech, auth_string))
    smtp_conn = smtplib.SMTP_SSL("smtp.gmail.com", 465)
    smtp_conn.set_debuglevel(True)
    smtp_conn.ehlo("test")
    smtp_conn.docmd("AUTH", mech + " " + base64.b64encode(auth_string).decode())

def require_args(options, *args):
    missing = ["--%s" % arg for arg in args if getattr(options, arg.replace("-", "_")) is None]
    if missing:
        Core.die("missing options: %s" % ", ".join(missing))

def decline_args(options, *args):
    useless = ["--%s" % arg for arg in args if getattr(options, arg.replace("-", "_")) is not None]
    if useless:
        Core.warn("option %s useless in this mode" % ", ".join(useless))

def main(argv):
    parser = argparse.ArgumentParser()
    group = parser.add_argument_group("Token retrieval mode options")
    group.add_argument("--client-id", help="client ID of the application")
    group.add_argument("--client-secret", help="client secret of the application")
    group.add_argument("--authorization-code", help="authorization code")
    group.add_argument("--refresh-token", help="OAuth2 refresh token")
    group.add_argument("--scope", default="https://mail.google.com/", help="scopes for the access token, space-separated")
    group.add_argument("--quiet", action="store_true", help="output only the token itself")
    group = parser.add_argument_group("Test client mode options")
    group.add_argument("--generate-sasl-response", action="store_true", help="generate an initial SASL client response string")
    group.add_argument("--test-imap", action="store_true", help="attempt to authenticate to Gmail via IMAP")
    group.add_argument("--test-smtp", action="store_true", help="attempt to authenticate to Gmail via SMTP")
    group.add_argument("--xoauth2", action="store_true", help="use legacy XOAUTH2 mechanism instead of OAUTHBEARER")
    group.add_argument("--user", help="specify the username (email address)")
    group.add_argument("--access-token", help="specify the access token")
    args = parser.parse_args()

    if (args.generate_sasl_response or args.test_imap or args.test_smtp):
        require_args(args, "user", "access-token")
        decline_args(args, "client-id", "client-secret", "refresh-token", "authorization-code")

        if args.xoauth2:
            mechanism = "XOAUTH2"
            response = sasl_xoauth2_response(args.user, args.access_token)
        else:
            mechanism = "OAUTHBEARER"
            response = sasl_oauthbearer_response(args.user, args.access_token)

        if args.generate_sasl_response:
            print(base64.b64encode(response).decode())
        elif args.test_imap:
            test_imap_auth(args.user, mechanism, response)
        elif args.test_smtp:
            test_smtp_auth(args.user, mechanism, response)

    elif args.authorization_code:
        require_args(args, "client-id", "client-secret")
        decline_args(args, "user", "access-token", "refresh-token")
        response = get_access_token(args.client_id, args.client_secret, args.authorization_code)
        if args.quiet:
            print(response["access_token"])
            print(response["refresh_token"])
        else:
            print(json.dumps(response))

    elif args.refresh_token:
        require_args(args, "client-id", "client-secret", "refresh-token")
        decline_args(args, "user", "access-token", "authorization-code")
        response = refresh_access_token(args.client_id, args.client_secret, args.refresh_token)
        if args.quiet:
            print(response["access_token"])
        else:
            print(json.dumps(response))

    else:
        require_args(args, "client-id", "client-secret")
        decline_args(args, "user", "access-token")
        url = make_oauth2_permission_url(args.client_id, args.scope)
        if args.quiet:
            print(url)
            authorization_code = input()
        else:
            print("Visit this URL:", url)
            authorization_code = input("Enter verification code: ")
        response = get_access_token(args.client_id, args.client_secret, authorization_code)
        if args.quiet:
            print(response["refresh_token"])
        else:
            print(json.dumps(response))

if __name__ == "__main__":
    main(sys.argv)
